Texturing and Texture animation: Ruth
I referenced texture.cpp from HW4 to implement the texture pipeline. In order to separate the solid and the transparent blocks, when I make the chunks, I first determine whether the block should be drawn as a transparent block or a solid block. This determines which VBO the block gets pushed into. Then I use a bunch of if-statements to determine whether the face on the block should be drawn or not/pushed in or not.
In order to use the UV coords to color block faces, I chose to overwrite the data in the vec4 that passed color data. So rather than pass a vec2, instead, I am passing a vec4 whose x and y values are UV coords.
To check whether the UV needs to move or not, I have a flag that determines if the x value of the UV coords of this pixel fall within the bounds of a lava or a water texture. To make the UVs move, I decided to offset the x value by a modded value over time. This ensures that when the coords reach the end of the texture, they loop back to the start point to begin sampling again.

Multithreading: Benjamin Sei
I decided to implement multithreaded terrain generation using the C++ standard library. Because of how child threads are created, I had to make functions, equivalent to QT's thread class' run(), which did not rely on an instance of Terrain. In terms of structure, terrain would be expanded as follows: check each terrain around the player and populate each chunk with procedural data and store each chunk in a vector, iterate over the vector of chunks with block data and generate VBOs then push those chunks in another vector, finally push the VBO data one by one by iterating over each chunk with VBO data. To ensure the shared resources (vector of chunks with block data, vector of chunks with VBO data), were modified properly I made two wrapper classes, one for block data and one for VBO data, with each containing it's own mutex. Whenever a method was called to modify a shared resource, the mutex would be locked and unlocked accordingly. 

Lsystem Rivers: Kaiying Guo
I created a lsystem and turtle class to create my rivers. The turtle class stored aspects of the river including the start position and width. I created a grammar and a grammar parser function that is typical of any lsystem. For carving the river segments, I used a capsule. I checked all the blocks within the bounding box of the capsule. A block is within the capsule bounds, I check if the the y value of the block is lower than the water table. If it is, then the block is set to water. If it is above, I set the block as empty. I only check for the bottom half of the capsule for collision. All blocks are automatically removed if the y is above the capsule center y. The shape of the capsule guarantees I am "scooping" aka the terrain slopes downward from the river. In player.cpp I checked if the player was in water within the grid march and reduced the movement amount if the player was. For post processing.. I tried really hard to made a post processing pipeline with the frame buffer but it did not really work. In the end I just created a uniform handle of type int that represented the environment the camera was in. I set the handle to an 0,1,2 depending on if the camera is in water, lava, or air. In the fragment shader, I used the handle to decide whether to amp the blue values for water, or red values for lava. 

