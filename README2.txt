Texturing and Texture animation: Ruth
I referenced texture.cpp from HW4 to implement the texture pipeline. In order to separate the solid and the transparent blocks, when I make the chunks, I first determine whether the block should be drawn as a transparent block or a solid block. This determines which VBO the block gets pushed into. Then I use a bunch of if-statements to determine whether the face on the block should be drawn or not/pushed in or not.
In order to use the UV coords to color block faces, I chose to overwrite the data in the vec4 that passed color data. So rather than pass a vec2, instead, I am passing a vec4 whose x and y values are UV coords.
To check whether the UV needs to move or not, I have a flag that determines if the x value of the UV coords of this pixel fall within the bounds of a lava or a water texture. To make the UVs move, I decided to offset the x value by a modded value over time. This ensures that when the coords reach the end of the texture, they loop back to the start point to begin sampling again.

Multithreading: Benjamin Sei
I decided to implement multithreaded terrain generation using the C++ standard library. Because of how child threads are created, I had to make functions, equivalent to QT's thread class' run(), which did not rely on an instance of Terrain. In terms of structure, terrain would be expanded as follows: check each terrain around the player and populate each chunk with procedural data and store each chunk in a vector, iterate over the vector of chunks with block data and generate VBOs then push those chunks in another vector, finally push the VBO data one by one by iterating over each chunk with VBO data. To ensure the shared resources (vector of chunks with block data, vector of chunks with VBO data), were modified properly I made two wrapper classes, one for block data and one for VBO data, with each containing it's own mutex. Whenever a method was called to modify a shared resource, the mutex would be locked and unlocked accordingly. 
