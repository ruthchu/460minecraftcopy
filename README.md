PROCEDURAL: Implemented by Benjamin Sei
I will begin by discussing how I implemented the function to generate the height of a block in the grassland biome. The basis of the noise function I used was a variant of Worley Noise. As discussed in the paper linked in the writeup, I first altered the Worley Noise as presented in class to form cellular structures which would form the basis of the hill, or mounds, in the grassland. Specifically, I kept track of a new parameter to store the second smallest distance (in addition to the smallest) and used it as described by the paper. To spice up the noise a bit in order to create the sense of natural rolling hills rather than neat uniform-like mounds, I introduced fbm noise in between the mounds and around the perimeter of the mounds to distort/warp areas that were too uniform. In the beginning, I had issues where upon import everything from the shader homework, the blocks were strangely divided into flat eight by eight chunks, but this was easily (but not painlessly) fixed by making sure the inputted x and z coordinates were properly casted to floats (before being divided among other manipulations). I decided to calculate the final height in the world by mapping the result of the noise to [baseheight, baseheight + range].
Onto the mountain biome. The basis of the noise function I used was a variant of Perlin noise. Speifically, a transformation of Perlin noise of the form 1 - abs(perlin). As shown in lecture, this gives us streaks of bright "lines" which lay the foundation of mountain ranges. I decided to spice up the result of the noise by calculating an offset using Perlin noise, then apply that offset to the original input to Perlin noise in an effort to enhance the feeling of randomness. The issue I had here was that I simply passed in unaltered x and z coordinates as the input to Perlin. However, this simply created a flat terrain (in the testScene) since my definition of Perlin noise would treat "similar" integers to be the same inputs since they didn't vary enough. Similar to the grass biome, I decided to calculate the final height in the world by mapping the result of the noise to [baseheight, baseheight + range].
Now onto the interpolation of both biomes. My decision was to use Perlin noise as the third noise function to blend the two biomes. I began by calculating the final height using the grass and mountain height (returned by the two functions described above), and used mix() on those values along with the result of the Perlin noise. The blocktype was decided by whether the result of Perlin gave a value greater than 0.5 or not. However, the end product was strange terrain which seemed more mountainous than hilly, even in areas which had grass and were supposedly rolling grasslands. I was stuck on this for a while until I realized that in areas of grass or mountain biome, it would be best if less of the other biome's height contributed to the final height of the block. That is, the height of blocks in grass biomes would be mostly influenced by the height returned by the grass function, and likewise for the mountain biomes (influenced mainly by mountain height). Thus I altered my calculations so that the final height was of the form grass_height * grass_weight + mountain_height * mountain_weight. To calculate the weight of a biome, I decided to skew the weight of a certain biome using a smoothstep on the Perlin noise where it's parameters were reliant on whether or not the Perlin was above or below 0.5. That is, Perlin values above 0.5, hich corresponded to mountain biomes, would have the weight be smoothstepped on [0.6, 1] (grasslands which [0, 0.3].

I decided to throw all my noise functions inside a different file (Noise.h/cpp) so that I could grab what functions I needed when I needed.
After setting the final height of a block dictated by the biome, I decided to use a helper function which iteratively sets the height of blocks from an inputed height down to 0.

CHUNKING: Implemented by Kaiying Guo 

First, I created an standard vector of vertex data comprised of normals, position, and color for every chunk. How I populated the standard vector, was by iterating through all all the blocks in a chunk and comparing each block to its neighboring blocks on all enum directions. If the neighboring block of a face is empty, then the face of the block id drawn via triangulation. The normal is dependent on the face and the color is derivied from the block type which I use a switch statment to implement. I found the positions of the face by offsetting the block position in world which is a block bottom left. 

When I arrive at the edges of the chunk, I compare the edge blocks to blocks of a neighboring chunk if the chunk in question exists. I only check the edges of the chunk in x and z because the y edges should always be there. 

I created another VBO on the GPU which stored a new handle BufAll for all interleaved data.  The shaderprogram's draw was modified such that vertex, position, and color data are read from the same VBO using offsets and strides. 

Lastly, I created a function called from Tick which creates 100 chunks surrounding the chunk the player is currently standing on if they are not already created. I modified renderTerrain's params to be based on the player position and rendered a 8 by 8 chunk space with the player's standing chunk in the middle. The terrain.draw was simplified to just draw chunks.

The hardest part was understanding the infinite terrain generation. At first I though I needed to create neighbors, but in the end I realized it was just easier to loop over an area around the player and guarentee terrain. 

ENGINE: Implemented by Ruth Chung

I had the most trouble implementing the way the camera moves when the player shifts their mouse. I solved this by adding two varaibles inside the input bundle that tracked the previous mouse x and y position. These got hardcoded to the middle of the screen, and every time the player moves their mouse, I call a function that was provided to bring the cursor back to the middle of the screen.

In order to register whether a key was being pressed or not, I made use of the input bundle, and also added a keyReleaseEvent listener for each relevant key. I added a boolean in the input bundle to track when Q and E are pressed. Inside the player class, I added a variable that tracked whether flight mode was activated or not.

I modified processInputs to also take in dT so that I could normalize acceleration speed across different computers. My group was having an issue where the controls were too sensitive because the dT would vary across computers. So I multiply all constant player physics values by 1 / dT to keep control sensitivity the same across devices.

Inside processInputs, I first calculate the rotation based on the mouseX and mouseY. Left-right rotation is around the global up vector and up-down rotation is around the local right vector. The left-right rotation is around the global vector to keep the camera from rotating weird directions when it is looking down or up. When looking down and up, the view angle is clamped to 90 degrees so the camera cannot flip all the way over.

I start by setting the acceleration vec to 0. If flight mode is activated, then keypresses for Q and E are registered and spacebar is not. If flight mode is off, then Q and E have no functionality and spacebar does. Each keypress modifies the acceleration vector, or velocity vector in the case of spacebar.

Inside computePhysics, I calculate the new velocity by adding dT * m_acceleration to the old velocity, and then use that to calculate a vec3 that represents the player's movement from their current position. If flight mode is off, then this is used to calculate collisions.

In order to calculate collisions, I use nested for-loops to iterate through the 12 points that represent our player volume. From each point, I cast 3 rays that correspond to the x, y, and z vectors of the move vector using the function gridMarch(). If any of these vectors are shorter than the value in the original move vector, I replace the value in the move vector with the shortened distance. To make sure the player actually collides, the shortened distance is modified by a value of .0001

After this, I use the function moveAlongVector() with the modified move vector to shift the player in the right direction.

To remove blocks, on leftClick, I cast a ray from the camera position of length 3 along the camera look vector, using the function gridMarch(). If it intersects with anything, I remove the block at that position.

To add blocks, on rightClick, I cast a ray from the camera position of length 3 along the camera look vector, using the function gridMarch(). If it intersects a block, I first find the middle of that block, and the point where the ray intersects that block. Then, I take the difference between those two positions. The component in this vector with the largest difference indicates the face that the block should be placed adjacent to. Using this information, I modify the hitBlock coordinates accordingly to place the new block in the proper position.
